// src/dbml.ts
var DBML = class {
  built = "";
  insert(str) {
    this.built += str;
    return this;
  }
  concatAll(strs) {
    for (let i = 0; i < strs.length; i++) {
      this.insert(strs[i]);
      this.newLine(2);
    }
    return this;
  }
  /**
   * Escapes characters that aren't allowed in DBML surrounding the input with double quotes
   */
  escapeSpaces(str) {
    this.built += /\W/.test(str) ? `"${str}"` : str;
    return this;
  }
  escapeType(str) {
    this.built += str.includes(" ") || str.includes(")[") ? `"${str}"` : str;
    return this;
  }
  newLine(newLines = 1) {
    this.built += "\n".repeat(newLines);
    return this;
  }
  tab(tabs = 1) {
    this.built += " ".repeat(tabs * 2);
    return this;
  }
  build() {
    return this.built.trimEnd();
  }
};

// src/utils.ts
function formatList(items, escapeName, escapeSpaces = false) {
  return items.reduce(
    (str, item) => `${str}, ${escapeSpaces && item.includes(" ") ? escapeName(item) : item}`,
    ""
  ).slice(2);
}
function wrapColumns(columns, escapeName) {
  const formatted = formatList(
    columns.map((column) => column.name),
    escapeName,
    true
  );
  return columns.length === 1 ? columns[0].name : `(${formatted})`;
}
function wrapColumnNames(columns, escapeName) {
  return columns.length === 1 ? columns[0] : `(${formatList(columns, escapeName)})`;
}

// src/generators/common.ts
import {
  One,
  Relations,
  SQL,
  createMany,
  createOne,
  getTableColumns,
  is,
  Column
} from "drizzle-orm";

// src/symbols.ts
var AnyInlineForeignKeys = Symbol.for("drizzle:AnyInlineForeignKeys");
var PgInlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var MySqlInlineForeignKeys = Symbol.for("drizzle:MySqlInlineForeignKeys");
var SQLiteInlineForeignKeys = Symbol.for("drizzle:SQLiteInlineForeignKeys");
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");

// src/generators/common.ts
import {
  ForeignKey as PgForeignKey,
  Index as PgIndex,
  PrimaryKey as PgPrimaryKey,
  UniqueConstraint as PgUniqueConstraint,
  isPgEnum,
  PgTable
} from "drizzle-orm/pg-core";
import {
  ForeignKey as MySqlForeignKey,
  Index as MySqlIndex,
  PrimaryKey as MySqlPrimaryKey,
  MySqlTable,
  UniqueConstraint as MySqlUniqueConstraint
} from "drizzle-orm/mysql-core";
import {
  ForeignKey as SQLiteForeignKey,
  Index as SQLiteIndex,
  PrimaryKey as SQLitePrimaryKey,
  SQLiteTable,
  UniqueConstraint as SQLiteUniqueConstraint
} from "drizzle-orm/sqlite-core";
import { writeFileSync } from "fs";
import { resolve } from "path";
var BaseGenerator = class {
  schema;
  relational;
  generatedRefs = [];
  InlineForeignKeys = AnyInlineForeignKeys;
  buildQueryConfig = {
    escapeName: () => "",
    escapeParam: () => "",
    escapeString: () => ""
  };
  constructor(schema, relational) {
    this.schema = schema;
    this.relational = relational;
  }
  isIncremental(_column) {
    return false;
  }
  mapDefaultValue(value) {
    let str = "";
    if (typeof value === "string") {
      str = `'${value}'`;
    } else if (typeof value === "boolean" || typeof value === "number") {
      str = `${value}`;
    } else if (value === null) {
      str = "null";
    } else if (value instanceof Date) {
      str = `'${value.toISOString().replace("T", " ").replace("Z", "")}'`;
    } else if (is(value, SQL)) {
      str = `\`${value.toQuery(this.buildQueryConfig).sql}\``;
    } else {
      str = `\`${JSON.stringify(value)}\``;
    }
    return str;
  }
  generateColumn(column) {
    const dbml = new DBML().tab().escapeSpaces(column.name).insert(" ").escapeType(column.getSQLType());
    const constraints = [];
    if (column.primary) {
      constraints.push("pk");
    }
    if (column.notNull) {
      constraints.push("not null");
    }
    if (column.isUnique) {
      constraints.push("unique");
    }
    if (this.isIncremental(column)) {
      constraints.push("increment");
    }
    if (column.default !== void 0) {
      constraints.push(`default: ${this.mapDefaultValue(column.default)}`);
    }
    if (constraints.length > 0) {
      dbml.insert(` [${formatList(constraints, this.buildQueryConfig.escapeName)}]`);
    }
    return dbml.build();
  }
  generateTable(table) {
    if (!this.relational) {
      this.generateForeignKeys(table[this.InlineForeignKeys]);
    }
    const dbml = new DBML().insert("table ");
    if (table[Schema]) {
      dbml.escapeSpaces(table[Schema]).insert(".");
    }
    dbml.escapeSpaces(table[TableName]).insert(" {").newLine();
    const columns = getTableColumns(table);
    for (const columnName in columns) {
      const column = columns[columnName];
      const columnDBML = this.generateColumn(column);
      dbml.insert(columnDBML).newLine();
    }
    const extraConfigBuilder = table[ExtraConfigBuilder];
    const extraConfigColumns = table[ExtraConfigColumns];
    const extraConfig = extraConfigBuilder?.(extraConfigColumns ?? {});
    const builtIndexes = Object.values(extraConfig ?? {}).map((b) => b.build(table));
    const fks = builtIndexes.filter(
      (index) => is(index, PgForeignKey) || is(index, MySqlForeignKey) || is(index, SQLiteForeignKey)
    );
    if (!this.relational) {
      this.generateForeignKeys(fks);
    }
    if (extraConfigBuilder && builtIndexes.length > fks.length) {
      const indexes = extraConfig ?? {};
      dbml.newLine().tab().insert("indexes {").newLine();
      for (const indexName in indexes) {
        const index = indexes[indexName].build(table);
        dbml.tab(2);
        if (is(index, PgIndex) || is(index, MySqlIndex) || is(index, SQLiteIndex)) {
          const configColumns = index.config.columns.flatMap(
            (entry) => is(entry, SQL) ? entry.queryChunks.filter((v) => is(v, Column)) : entry
          );
          const idxColumns = wrapColumns(
            configColumns,
            this.buildQueryConfig.escapeName
          );
          const idxProperties = index.config.name ? ` [name: '${index.config.name}'${index.config.unique ? ", unique" : ""}]` : "";
          dbml.insert(`${idxColumns}${idxProperties}`);
        }
        if (is(index, PgPrimaryKey) || is(index, MySqlPrimaryKey) || is(index, SQLitePrimaryKey)) {
          const pkColumns = wrapColumns(index.columns, this.buildQueryConfig.escapeName);
          dbml.insert(`${pkColumns} [pk]`);
        }
        if (is(index, PgUniqueConstraint) || is(index, MySqlUniqueConstraint) || is(index, SQLiteUniqueConstraint)) {
          const uqColumns = wrapColumns(index.columns, this.buildQueryConfig.escapeName);
          const uqProperties = index.name ? `[name: '${index.name}', unique]` : "[unique]";
          dbml.insert(`${uqColumns} ${uqProperties}`);
        }
        dbml.newLine();
      }
      dbml.tab().insert("}").newLine();
    }
    dbml.insert("}");
    return dbml.build();
  }
  generateEnum(_enum_) {
    return "";
  }
  generateForeignKeys(fks) {
    for (let i = 0; i < fks.length; i++) {
      const sourceTable = fks[i].table;
      const foreignTable = fks[i].reference().foreignTable;
      const sourceSchema = sourceTable[Schema];
      const foreignSchema = foreignTable[Schema];
      const sourceColumns = fks[i].reference().columns;
      const foreignColumns = fks[i].reference().foreignColumns;
      const dbml = new DBML().insert(`ref ${fks[i].getName()}: `);
      if (sourceSchema) {
        dbml.escapeSpaces(sourceSchema).insert(".");
      }
      dbml.escapeSpaces(sourceTable[TableName]).insert(".").insert(wrapColumns(sourceColumns, this.buildQueryConfig.escapeName)).insert(" > ");
      if (foreignSchema) {
        dbml.escapeSpaces(foreignSchema).insert(".");
      }
      dbml.escapeSpaces(foreignTable[TableName]).insert(".").insert(wrapColumns(foreignColumns, this.buildQueryConfig.escapeName));
      const actions = [
        `delete: ${fks[i].onDelete || "no action"}`,
        `update: ${fks[i].onUpdate || "no action"}`
      ];
      const actionsStr = ` [${formatList(actions, this.buildQueryConfig.escapeName)}]`;
      dbml.insert(actionsStr);
      this.generatedRefs.push(dbml.build());
    }
  }
  generateRelations(relations_) {
    const left = {};
    const right = {};
    for (let i = 0; i < relations_.length; i++) {
      const relations = relations_[i].config({
        one: createOne(relations_[i].table),
        many: createMany(relations_[i].table)
      });
      for (const relationName in relations) {
        const relation = relations[relationName];
        const tableNames = [
          relations_[i].table[TableName],
          relation.referencedTableName
        ].sort();
        const key = `${tableNames[0]}-${tableNames[1]}${relation.relationName ? `-${relation.relationName}` : ""}`;
        if (is(relation, One) && relation.config?.references.length || 0 > 0) {
          left[key] = {
            type: "one",
            sourceSchema: relation.sourceTable[Schema],
            sourceTable: relation.sourceTable[TableName],
            sourceColumns: relation.config?.fields.map((col) => col.name) || [],
            foreignSchema: relation.referencedTable[Schema],
            foreignTable: relation.referencedTableName,
            foreignColumns: relation.config?.references.map((col) => col.name) || []
          };
        } else {
          right[key] = {
            type: is(relation, One) ? "one" : "many"
          };
        }
      }
    }
    for (const key in left) {
      const sourceSchema = left[key].sourceSchema || "";
      const sourceTable = left[key].sourceTable || "";
      const foreignSchema = left[key].foreignSchema || "";
      const foreignTable = left[key].foreignTable || "";
      const sourceColumns = left[key].sourceColumns || [];
      const foreignColumns = left[key].foreignColumns || [];
      const relationType = right[key]?.type || "one";
      if (sourceColumns.length === 0 || foreignColumns.length === 0) {
        throw Error(
          `Not enough information was provided to create relation between "${sourceTable}" and "${foreignTable}"`
        );
      }
      const dbml = new DBML().insert("ref: ");
      if (sourceSchema) {
        dbml.escapeSpaces(sourceSchema).insert(".");
      }
      dbml.escapeSpaces(sourceTable).insert(".").insert(wrapColumnNames(sourceColumns, this.buildQueryConfig.escapeName)).insert(` ${relationType === "one" ? "-" : ">"} `);
      if (foreignSchema) {
        dbml.escapeSpaces(foreignSchema).insert(".");
      }
      dbml.escapeSpaces(foreignTable).insert(".").insert(wrapColumnNames(foreignColumns, this.buildQueryConfig.escapeName));
      this.generatedRefs.push(dbml.build());
    }
  }
  generate() {
    const generatedEnums = [];
    const generatedTables = [];
    const relations = [];
    for (const key in this.schema) {
      const value = this.schema[key];
      if (isPgEnum(value)) {
        generatedEnums.push(this.generateEnum(value));
      } else if (is(value, PgTable) || is(value, MySqlTable) || is(value, SQLiteTable)) {
        generatedTables.push(this.generateTable(value));
      } else if (is(value, Relations)) {
        relations.push(value);
      }
    }
    if (this.relational) {
      this.generateRelations(relations);
    }
    const dbml = new DBML().concatAll(generatedEnums).concatAll(generatedTables).concatAll(this.generatedRefs).build();
    return dbml;
  }
};
function writeDBMLFile(dbml, outPath) {
  const path = resolve(process.cwd(), outPath);
  try {
    writeFileSync(path, dbml, { encoding: "utf-8" });
  } catch (err) {
    console.error("An error ocurred while writing the generated DBML");
    throw err;
  }
}

// src/generators/pg.ts
var PgGenerator = class extends BaseGenerator {
  InlineForeignKeys = PgInlineForeignKeys;
  buildQueryConfig = {
    escapeName: (name) => `"${name}"`,
    escapeParam: (num) => `$${num + 1}`,
    escapeString: (str) => `'${str.replace(/'/g, "''")}'`
  };
  isIncremental(column) {
    return column.getSQLType().includes("serial");
  }
  generateEnum(enum_) {
    const dbml = new DBML().insert("enum ").escapeSpaces(enum_.enumName).insert(" {").newLine();
    for (let i = 0; i < enum_.enumValues.length; i++) {
      dbml.tab().escapeSpaces(enum_.enumValues[i]).newLine();
    }
    dbml.insert("}");
    return dbml.build();
  }
};
function pgGenerate(options) {
  options.relational ||= false;
  const dbml = new PgGenerator(options.schema, options.relational).generate();
  options.out && writeDBMLFile(dbml, options.out);
  return dbml;
}

// src/generators/mysql.ts
import { is as is2 } from "drizzle-orm";
import { MySqlColumnWithAutoIncrement } from "drizzle-orm/mysql-core";
var MySqlGenerator = class extends BaseGenerator {
  InlineForeignKeys = MySqlInlineForeignKeys;
  buildQueryConfig = {
    escapeName: (name) => `\`${name}\``,
    escapeParam: (_num) => "?",
    escapeString: (str) => `'${str.replace(/'/g, "''")}'`
  };
  isIncremental(column) {
    return column.getSQLType().includes("serial") || is2(column, MySqlColumnWithAutoIncrement) && column.autoIncrement;
  }
};
function mysqlGenerate(options) {
  options.relational ||= false;
  const dbml = new MySqlGenerator(options.schema, options.relational).generate();
  options.out && writeDBMLFile(dbml, options.out);
  return dbml;
}

// src/generators/sqlite.ts
import { is as is3, SQL as SQL2 } from "drizzle-orm";
import { SQLiteBaseInteger } from "drizzle-orm/sqlite-core";
var SQLiteGenerator = class extends BaseGenerator {
  InlineForeignKeys = SQLiteInlineForeignKeys;
  buildQueryConfig = {
    escapeName: (name) => `"${name}"`,
    escapeParam: (_num) => "?",
    escapeString: (str) => `'${str.replace(/'/g, "''")}'`
  };
  isIncremental(column) {
    return is3(column, SQLiteBaseInteger) && column.autoIncrement;
  }
  mapDefaultValue(value) {
    let str = "";
    if (typeof value === "string") {
      str = `'${value}'`;
    } else if (typeof value === "boolean") {
      str = `${value ? 1 : 0}`;
    } else if (typeof value === "number") {
      str = `${value}`;
    } else if (value === null) {
      str = "null";
    } else if (is3(value, SQL2)) {
      str = `\`${value.toQuery(this.buildQueryConfig).sql}\``;
    } else {
      str = `\`${JSON.stringify(value)}\``;
    }
    return str;
  }
};
function sqliteGenerate(options) {
  options.relational ||= false;
  const dbml = new SQLiteGenerator(options.schema, options.relational).generate();
  options.out && writeDBMLFile(dbml, options.out);
  return dbml;
}
export {
  mysqlGenerate,
  pgGenerate,
  sqliteGenerate
};
